# CleanCode
## :pencil: TIL  
### DAY 1 (2022.02.19)
:book: 오늘 읽은 범위 : 추천사 ~ 1장, 깨끗한 코드
---
> :smile: **책에서 기억하고 싶은 내용을 써보세요.**
 - 코드 품질을 측정하는 유일한 척도 = 분당 내지르는 WTF! 횟수 (들어가면서)
 - 나중은 결코 오지 않는다. (p.4)
 - 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다. (p.7)
 - 의존성을 최대한 줄여야 유지보수가 쉬워진다. (p.9 비야네 스트롭스트룹)
 - 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다. (p.10 그래디 부치)
 - 중복을 피하라. 한 기능만 수행하라. 제대로 표현하라. 작게 추상화하라. (p.14)
 - 읽으면서 짐작한 대로 돌아가는 코드가 깨끗한 코드다. (p.15)
 - 급하다면, 서둘러 끝내려면, 쉽게 짜려면, 일기 쉽게 만들면 된다. (p.18)
 
> :thinking: **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**
 - 이 책을 읽는다고 뛰어난 코더가 되는건 아닐 것이다. 다만 뛰어난 코더가 되기 위한 기술을 배울 수 있을 것이다.
 - 돌아가지 않는 코드보단 쓰레기지만 돌아가는 코드가 더 좋다고 생각해왔다. 하지만 이 책에서 이 이론에 정곡을 찌를 수 있었다.
 - 더 빠르게 가기 위해선 어렵지만 깨끗한 코드를 짜는게 더 효율적이라는 것을 깨달을 수 있었다.
 - 더러운 코드는 업무를 방해할 뿐일 것이다. `Simple is Best!`

> :mag_right: **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 - 르블랑의 법칙(leblanc's Law)


### DAY 2 (2022.02.20)
:book: 오늘 읽은 범위 : 2장, 의미 있는 이름
---
> :smile: **책에서 기억하고 싶은 내용을 써보세요.**
 - "의도가 분명하게 이름을 지으라" (p.22)
 - 프로그래머에게 List라는 단어는 특수한 의미다. (p.24)
 - 연속적인 숫자를 덧붙인 이름(a1, a2, ..., aN)은 의도적인 이름과 정반대다. (p.26)
 - 읽는 사람이 차이를 알도록 이름을 지어라. (p.27)
 - 이름 길이는 범위 크기에 비례해야 한다. (p.28)
 - 헝가리식 표기법이나 기타 인코딩 방식이 오히려 방해가 될 뿐이다. (p.30)
 - 독자가 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 그 변수 이름은 바람직하지 못하다. (p.31)
 - 일관성 있는 어휘는 코드를 사용할 프로그래머가 반갑게 여길 선물이다. (p.33)
 - 일반적으로는 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서다. (p.37)
 
> :thinking: **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**
 - 평소 네이밍을 어려워 했는데 이번 챕터를 보고 한 숨 놓은 느낌이 든다.
 - 이름은 길어도 자세하고 의미가 명확하게 작성한다. 하지만 의미가 명확한 선에선 짧은 이름이 좋다.
 - 이름을 짓기 위해 영어공부를 해야 할 것 같다.....
 - 접두사를 즐겨 썼었는데 필요한 부분 아니고선 줄여야 한다!

> :mag_right: **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 - 인코딩의 정확한 뜻?
 - 왜 실무에서는 이름을 이해하기 위해 회사명, 개발자명 등에 대해 자세히 알아야 할까? (실무경험 부족..)


### DAY 3 (2022.02.22)
:book: 오늘 읽은 범위 : 3장, 함수
---
> :smile: **책에서 기억하고 싶은 내용을 써보세요.**
 - 함수를 만드는 첫째 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다. (p.42) 
 if문 / else문 / while문 등에 들어가는 블록은 한 줄이어야 하며 함수에서 들여쓰기 수준은 1단이나 2단을 넘어가면 안된다.
 - 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다. (p.44)
 - 함수에서 이상적인 인수 개수는 0개(무항)다. (p.50)
 - 플래그 인수는 추하다. (p.52)
 플래그 인수는 bool형 값을 말한다. bool형 인수는 금지!
 - 함수 이름에 키워드를 추가하는 형식이다. 즉, 함수 이름에 인수 이름을 넣는다. (p.54)
 assertEquals 보다 assertExpectedEqualsActual(expected, actual)이 더 좋다!
 - 부수 효과는 거짓말이다. (p.54)
 - try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다. (p.58)
 - 어쩌면 중복은 소프트웨어에서 모든 악의 근원이다. (p.60)
 
 
> :thinking: **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**
 - 진짜 이번 챕터를 읽고 속으로 감탄을 수십번은 한 것 같다. 여태까지 내가 짰던 함수들은 다 쓰레기 그 자체였다. 내가 짰던 함수들을 다시 보려하니 구역질이 나온다.
   어떻게 이렇게 못생기게 짰지? 라는 생각이 이 독후감을 쓰면서도 계속 든다. 책 앞에 '추천사'에서 이 책을 읽고 한동안 코드를 짜기 싫어졌다라는 문장을 봤었는데 그 때는 왜 읽기 싫었을까?, 이 책을 봤으면 더욱 짜고 싶어져야 하는게 아닌가 라는 생각을 했었다. 하지만 지금 겨우 3장밖에 안왔는데도 그 문장에 공감하게 된다. 내가 짰던 코드들이 보기 미워지고 앞으로 짤 코드는 이 책이 말했던 요구들을 잘 담을 수 있을까? 라는 생각이 든다. 그래도 내일부터는 내가 짰던 코드들을 다시 봐야겠다. 다시 보는 과정에서 날 몇번이고 때릴 수 있지만 그래도 보면서 직접 고치고 싶다.  

> :mag_right: **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 - FitNesse (오픈 소스 테스트 도구)
 - JUnit (오픈 소스 단위 테스트 도구)
 - TO
 - 추상화 수준의 정확한 의미...??
 추상화 수준이 높다는 것 : 숨겨진 내용이 많다는 것
 추상화 수준이 낮다는 것 : 숨겨진 내용 없이 디테일하게 표현했다는 것
 - SRP, OCP


### DAY 4 (2022.02.25)
:book: 오늘 읽은 범위 : 4장, 주석
---
> :smile: **책에서 기억하고 싶은 내용을 써보세요.**
 - 부정확한 주석은 아예 없는 주석보다 훨씬 더 나쁘다. (p.69)
 - 자신이 저지른 난장판을 주석으로 설명하려 애쓰는 대신에 그 난장판을 깨끗이 치우는 데 시간을 보내라! (p.69)
 - 주석을 달 때는 더 나은 방법이 없는지 고민하고 정확히 달도록 가별히 주의한다. (p.73)
 - 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화하는 등 프로그래머가 주절거리는 독백에서 크게 벗어나지 못한다. (p.76)
 - 있으나 마나 한 주석을 달려는 유혹에서 벗어나 코드를 정리하라. 더 낫고, 행복한 프로그래머가 되는 지름길이다. (p.83)
 - 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자. (p.85)
 - 주석으로 처리한 코드만큼 밉살스러운 관행도 드물다. (p.86)
 - 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라. (p.88)
 
> :thinking: **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**
 - 이 챕터의 시작부터 끝까지 말하는 바는 다음과 같다. "주석을 필요한 경우 이외에는 최대한 적게 사용하라"
 - 나는 여태까지 좋은 코드의 기준은 많은 주석이라 생각했다. 때문에 내가 짠 코드엔 코딩을 하지 않는 사람도 읽기 쉽도록 주석을 많이 달아왔었다. 하지만 이 책의 저자는 그런 짓은 오히려 독이라고 분명히 말해주는 것 같았다.
   코드를 읽는 독자는 항상 같은 프로그래머라고 생각해야 한다. 기준을 프로그래머에게 둬야 한다. 때문에 주석을 다는 것이 아닌 함수명 또는 변수명 등을 적절히 지어줌으로써 코드 자체가 설명하도록 노력해야 한다.
   
> :mag_right: **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 - 톰캣?
 - 자바에서 @param이 뭐였더라...?? : @param은 매개변수 추가 설명


### DAY 5 (2022.02.28)
:book: 오늘 읽은 범위 : 5장, 형식 맞추기
---
> :smile: **책에서 기억하고 싶은 내용을 써보세요.**
 - 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. (p.96)
 - 일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다. (p.97)
 - 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다. (p.100)
 - 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다. (p.104)
 - 친화도가 높을수록 코드를 가까이 배치한다. (p.106)
 - 개인적으로는 120자 정도로 행 길이를 제한한다. (p.108)
 - 할당 연산자를 강조하려고 앞뒤에 공백을 줬다. 반면, 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다. 함수와 인수는 서로 밀접하기 때문이다. (p.108)
 - 팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다. (p.113)
 
> :thinking: **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**
 - 들여쓰기, 띄어쓰기 등의 코드 작성 형식들은 코드를 이해하는데 매우 중요하다고 생각하고 있다. 하지만 가끔 한줄자리 if문이나 반복문 등을 들여쓰기가 귀찮다는 이유로 아니면 멋있게 써볼려는
 이유로 띄어쓰기 조차 안쓰고 한줄로 냅다 구겨넣은적이 있었다. 그런 식의 구겨넣기는 하면 안되는 행동이며 최대한 깔끔하고 가독성 있게 작성해야 한다.
 - 조금 옛날에 알고리즘 문제에 익숙하지 않던 시절 카페에다가 이러한 질문을 남겼었다. "보통 알고리즘 문제 푸시면은 몇줄자리 코드로 푸시나요??" 지금이나 그때 생각해봐도 웃긴 질문이였다. 당연히 답변자는
 무슨 이런 멍청한 질문이 있나 하고 넘겼을 것이다. 지금와서 내가 그 질문에 대답하자면 무조건 코드는 짧게! 하지만 가독성 있게 라고 답한다.
 - 협업을 할 때 그냥 저쪽이 쓴 코드하고 내가 쓴 코드하고 아무렇게나 엉켜 합친 적이 많았다. 하지만 이건 좋지않은 협업 습관이다. 협업을 하기 전엔 코드를 어떻게 작성해야 할지 의논하고 작성해야 한다.
 앞으로는 그럴 것이다!

> :mag_right: **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 - 가위 규칙??


### DAY 6 (2022.03.01)
:book: 오늘 읽은 범위 : 6장, 객체와 자료 구조
---
> :smile: **책에서 기억하고 싶은 내용을 써보세요.**
 - 구현을 감추려면 추상화가 필요하다! (p.119)
 - 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다. (p.119)
 - 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. (p.122)
 - 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다. (p.122)
 - 분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다. 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.
 - 디미터 법칙은 "클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다"고 주장했다.
 => 클래스 C, f가 생성한 객체, f인수로 넘어온 객체, C인스턴스 변수에 저장된 객체
 - 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다. (p.124)
 - (잡종 구조는) 프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해 (더 나쁘게는 무지해) 어중간하게 내놓은 설계에 불과하다. (p.125)
 - 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. (p.128)


> :thinking: **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**
 - 요즘엔 자료구조만 하다보니 객체지향의 개념에 대해 많이 약해진 감이 있었다. 이 챕터를 읽으면서 객체지향의 개념을 다시 한번 잡을 수 있었던 것 같다. 평소 객체지향 하면 '빈 구조'만 떠올랐는데
여러 다른 객체지향 유형을 볼 수 있어 좋았다.
 - 이번 챕터는 아무래도 내가 객체지향에 대한 이해가 부족하다 보니 읽기 힘든 감이 있었다. 그래도 객체지향의 본질적인 개념과 은닉성의 중요함 등 여러가지 깨달을 수 있었다. 나중에 객체지향 언어를 다시 공부하고 읽으면 그땐 더 많은 걸 얻어갈 수 있으리라 생각한다.

> :mag_right: **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 - 디미터 법칙 -> 잘 이해가.... ㅠㅠ
 - DTO?


### DAY 7 (2022.03.04)
:book: 오늘 읽은 범위 : 7장, 오류 처리
---
> :smile: **책에서 기억하고 싶은 내용을 써보세요.**
 - 오류가 발생하면 예외를 던지는 편이 낫다. 그러면 호출자 코드가 더 깔끔해진다. 논리가 오류 처리 코드와 뒤섞이지 않으니까. (p.131)
 - 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션
 본질을 유지하기 쉬워진다. (p.133)
 - 실제로 외부 API를 사용할 때는 감싸기 기법이 최선이다. 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 나중에 다른 라이브러리로 갈아타도 비용이 적다. 또한 감싸기 클래스에서 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다. (p.137)
 - 이를 특수 사례 패턴이라 부른다. 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이다. (p.138)
 - null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. (p.139)
 - null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다. (p.139)
 - 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. (p.142)

> :thinking: **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**
 - 내가 객체지향 언어를 사용해 본격적인 개발을 한 건 지금 하고 있는 게임 제작이 처음일 것이다. 게임 제작을 C#언어로 해오면서 코드에 여러 난관들을 겪어왔다. 그래서 여태 더러운 코드로 놔두고
특히, 이번 챕터에서 나오는 오류처리를 한번도 해주지 못했다. 최대한 오류가 안 나는 방향으로 개발하고 있지만 게임 유저들의 특성상 예외인 부분을 발견할 수 있고 그것 때문에 게임이 먹통이 될 수 있을 것이다.
 이렇게 내가 예외 처리를 잘 안쓰다 보니 이번 챕터도 읽기 살짝 어려운 감이 있었다. 하지만 이번 챕터로 부터 예외 처리의 중요성 만큼은 깨달은 것 같다. 또 특히 'null'을 최대한 반환하지 말라는 말에 공감을 했다.
 옛날에 null을 값으로 취급하고 사용하려다가 잘 안됐던 경험들이 있었는데 이 때문에 더욱 공감 되었던 것 같다.

> :mag_right: **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 - 외부 API를 감싸는 이유?? => https://armadillo-dev.github.io/javascript/we-should-wrapping-library/
 - 자바 assert문 사용법 => https://yeh35.github.io/blog.github.io/documents/java/java-assert/


### DAY 8 (2022.03.05)
:book: 오늘 읽은 범위 : 9장, 단위 테스트
---
> :smile: **책에서 기억하고 싶은 내용을 써보세요.**
 - TDD 법칙 세 가지 (p.155)
 1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
 2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
 3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
 - 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다. (p.155)
 - 테스트 코드는 실제 코드 못지 않게 중요하다. 테스트 코드는 이류 시민이 아니다. 테스트 코드는 사고와 설계와 주의가 필요하다.
 - 테스트 API코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르다. 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적인 필요는 없다. 실제 환경이 아니라 테스트 환경에서 돌아가는 코드이기 때문이다. (p.162)
 - assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. (p.164)
 - given-when-then 관례 (p.165)
 - 단지 assert 문 개수는 최대한 줄여야 좋다는 생각이다. (p.165)
 - 가장 좋은 규칙은 "개념 당 assert 문 수를 최소로 줄여라"와 "테스트 함수 하나는 개념 하나만 테스트하라"라 하겠다.
 - 깨끗한 테스트의 다섯가지 규칙 : F.I.R.S.T (p.167-p.168) 

> :thinking: **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**
 - 옛날에 어느 한 개발자한테 멘토링을 들었을 때 실제 개발하는 시간은 20% 이고 나머지 유지,보수,테스트 하는 시간이 80%라고 들었다. 아직 개발의 '개'자도 배우지 못한 나로선 그 얘기를 이해하긴 힘들었다. 물론 지금도 그렇고 말이다. 개발을 하다보면 코드에 코드가 뭉쳐저서 덩어리채로 나오는 경우가 있다. 이럴 때 제대로 동작하는지 확인하려 하면 매우 힘들다. 어디서부터 건들여야 할지도 모르겠고 말이다. 그래서 이 책에선 코드를 짜기 전에 테스트 케이스 부터 작성하고 들어가라고 하는것 같다. 테스트 케이스를 짜고 그것을 극복함으로써 코드가 진화를 한다. 한층 한층 진화하면서 최종 진화체가 나타나는 것이다. 
 - 내가 테스트 케이스를 짤땐 assert문 여러개를 그냥 뭉터기로 집어넣어 True가 나오는 걸 확인했다. 그러나 이건 매우 안좋은 습관임을 알게 되었다. 테스트 코드라 해도 좀 더 깔끔하게 작성하여 독자가 무었을 테스트 하고 무었을 극복하려 하는지 알아야 한다. 어짜피 지울거라도 말이다.

> :mag_right: **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 - BUILD-OPERATE-CHECK패턴 (p.161)
 - StringBuffer?


## :pencil: TIL  
### DAY 9 (2022.03.09)
:book: 오늘 읽은 범위 : 10장, 클래스
---
> :smile: **책에서 기억하고 싶은 내용을 써보세요.**
 - 변수 목록 다음에는 공개 함수가 나온다. 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다. 즉, 추상화 단계가 순차적으로 내려간다. 그래서 프로그램은 신문 기사처럼 읽힌다. (p.172)
 - 클래스를 만들 때 첫 번째 규칙은 크기다. 클래스는 작아야 한다. 두 번째 규칙도 크기다. 더 작아야 한다. (p.172)
 - 큼직한 다목적 클래스 몇 개로 이뤄진 시스템은 (변경을 가할 때) 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다. (p.177)
 - 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다. (p.177)
 - 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다. 일반적으로 이처럼 응집도가 가장 높은 클래스는 가능하지도 바람직하지도 않다. (p.177)
 - OCP란 클래스는 확장에 개방적이고 수정에 폐쇄적이어야 한다는 원칙이다. (p.188)
 - DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다. (p.190)

> :thinking: **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**
 - 클래스의 기본 원칙은 작게, 더 작게이다. 평소 클래스를 제작 할 때 다른 클래스에 넣기 귀찮으니 한 클래스에 몰아 부었던 적이 많았다. 평소에 이러는 나 또한 이런 습관이 안 좋은 습관이 아닐까 하며 
 고민한 적이 많았다. 하지만 또 한편으로는 그냥 하나의 클래스에 넣어 큼지막하게 이해하기도 편하고 굳이 잘 돌아가는 코드를 따로 클래스를 만들어서 옮겨야 하나라는 생각을 했다. 그러나 또 이런 나쁜 습관을
  이 책에서 잡아내 주었다. 클래스는 수정할 때 이유를 하나만 들 수 있게 더욱 작고도 작게 만들어야 한다. 그런 의미로 이 TIL작성을 마친 후 코드를 고치러 가봐야겠다.

> :mag_right: **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 - SRP
 - OCP, DIP
#노마드코더 #북클럽 #노개북 #클린코드
